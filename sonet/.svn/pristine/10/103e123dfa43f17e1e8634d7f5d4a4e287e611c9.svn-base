package pt.ist.sonet.domain;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;

import pt.ist.sonet.exception.*;

/**
 * SoNet e' uma rede social com agentes de diferentes tipos e que podem estabelecer
 * ligacoes entre si, criar pubicacoes e comenta-las. Existem restricoes de acesso
 * a determinadas informacoes por alguns agentes.
 * 
 * @author ES Grupo 8
 * 
 */


public class SoNet extends SoNet_Base implements Serializable {

	public static String ORGANIZATIONAL = "Organizational";
	public static String INDIVIDUAL = "Individual";
	public static String FRIEND = "amigo";
	public static String PUBLIC = "publica";
	public static String PRIVATE = "privado";
	private static final long serialVersionUID = 1L;



	public SoNet() {
		super();
		this.setFriendLimit(100);
	}

	/**
	 * Obtem agent por nome
	 * @param name
	 * @return Agent ou null se nao existir
	 */
	public Agent getAgentByName(String name) {
		for (Agent agent : getAgentSet()) {
			if (agent.getName().equals(name)) {
				return agent;
			}
		}
		return null;
	}

	/**
	 * Obtem agent por username
	 * @param user
	 * @return Agent ou null se nao existir
	 */
	public Agent getAgentByUsername(String user) {
		for (Agent agent : getAgentSet()) {
			if (agent.getUsername().equals(user)) {
				return agent;
			}
		}
		return null;
	}

	/**
	 * Verifica se exite um agent com um dado nome
	 * @param name
	 * @return boolean com o resultado
	 */
	public boolean hasAgentByName(String name) {
		return getAgentByName(name) != null;
	}
	/**
	 * Verifica se exite um agent com um dado username
	 * @param name
	 * @return boolean com o resultado
	 */
	public boolean hasAgentByUsername(String user) {
		return getAgentByUsername(user) != null;
	}

	/**
	 * Cria um novo agente organizacional na rede.
	 * Verifica a validade dos dados de utilizador de acordo com
	 * as regras de negocio estabelecidas. Lanca excepcoes caso
	 * existam dados invalidos.
	 * 
	 * @param username
	 * @param name
	 * @param email
	 * @param password
	 * @param city
	 * @param country
	 * @return Organizational instacia de agente criada
	 * @throws NameAlreadyExistsException
	 * @throws UsernameAlreadyExistsException
	 */
	public Organizational createOrganizationalAgent(String username,
			String name, String email, String password, String city,
			String country, String permission) throws NameAlreadyExistsException,
			UsernameAlreadyExistsException {
		for(Agent a : this.getAgentSet()){	
			if (a.getType().equals(ORGANIZATIONAL) && a.getName().equals(name))
				throw new NameAlreadyExistsException(name);
		}
		if (this.hasAgentByUsername(username))
			throw new UsernameAlreadyExistsException(username);

		Organizational agent = new Organizational(username, name, email,
				password, city, country, permission);
		return agent;
	}

	/**
	 * Cria um novo agente individual na rede.
	 * Verifica a validade dos dados de utilizador de acordo com
	 * as regras de negocio estabelecidas. Lanca excepcoes caso
	 * existam dados invalidos.
	 * 
	 * @param username
	 * @param name
	 * @param email
	 * @param password
	 * @param city
	 * @param country
	 * @return Individual instacia de agente Individual criada.
	 * @throws UsernameAlreadyExistsException
	 */
	public Individual createIndividualAgent(String username, String name,
			String email, String password, String city, String country, String permission)
					throws UsernameAlreadyExistsException {
		if (this.hasAgentByUsername(username))
			throw new UsernameAlreadyExistsException(username);

		Individual agent = new Individual(username, name, email, password, city, country, permission);
		return agent;
	}

	/** 
	 * Adiciona um agente criado 'a Base de Dados da rede.
	 * @param Agent agente a adicionar 'a BD.
	 * @see pt.ist.sonet.domain.SoNet_Base#addAgent(pt.ist.sonet.domain.Agent)
	 */
	@Override
	public void addAgent(Agent someone) {
		super.addAgent(someone);
	}

	/**
	 * Remove um agente da base de dados da SoNet.
	 * Lanca excepcao em caso de username inexistente.
	 * 
	 * @param username
	 * @throws AgentUsernameDoesNotExistsException
	 */
	public void removeAgent(String username)
			throws AgentUsernameDoesNotExistsException {
		Agent toRemove = getAgentByUsername(username);
		if (toRemove == null)
			throw new AgentUsernameDoesNotExistsException(username);
		super.removeAgent(toRemove);
	}

	/**
	 * Efectua uma pesquisa por uma palavra chave em todos os registos
	 * dos agentes existentes.
	 * 
	 * @param token
	 * @return
	 */
	public List<Agent> searchAgent(String token) {
		List<Agent> matchingAgents = new ArrayList<Agent>();

		for (Agent agent : this.getAgentSet()) {
			if (agent.getName().contains(token)
					|| agent.getCity().contains(token)
					|| agent.getCountry().contains(token)
					|| agent.getEmail().contains(token)) {
				matchingAgents.add(agent);
			}
		}

		return matchingAgents;
	}

	/**
	 * Obtem da BD a publicacao com o id indicado.
	 * 
	 * Lanca excepcao em caso de id inexistente.
	 * 
	 * @param id
	 * @return Publication instacia com o id indicado
	 * @throws PublicationIdDoesNotExistsException
	 */
	public Publication getPublicationById(int id)
			throws PublicationIdDoesNotExistsException {
		for (Publication pub : getPublicationsSet()) {
			if (pub.getId() == id) {
				return pub;
			}
		}
		throw new PublicationIdDoesNotExistsException(id);
	}

	/**
	 * Obtem o Set de publicacoes de um determinado agente.
	 * Retorna null em caso de o agente nao ter publicacoes.
	 * Lanca excepcao em caso de username inexistente.
	 * @param username
	 * @return Set<Publication> Set com as publicacoes do agente.
	 * @throws AgentUsernameDoesNotExistsException
	 */
	public Set<Publication> getUserPublicationsByUsername(String username)
			throws AgentUsernameDoesNotExistsException {
		Agent agent = this.getAgentByUsername(username);
		if (agent == null)
			throw new AgentUsernameDoesNotExistsException(username);
		return agent.getPublicationsSet();
	}

	/**
	 * Cria uma nova publicacao do tipo nota.
	 * 
	 * @param label
	 * @param creator
	 * @param text
	 * @return Note instacia de nota criada.
	 */
	public Note createNote(String label, Agent creator, String text) {
		int id = this.getPublicationIds();

		Note note = new Note(id, label, 0, 0, creator, text);
		id = id + 1;
		this.setPublicationIds(id);
		return note;
	}

	/**
	 * Cria uma nova publicacao do tipo conteudo.
	 * @param label
	 * @param creator
	 * @param url
	 * @return Content instacia de conteudo cirado.
	 */
	public Content createContent(String label, Agent creator, String url) {
		int id = this.getPublicationIds();

		Content content = new Content(id, label, 0, 0, creator, url);

		return content;
	}

	/**
	 * Adiciona uma nota 'a BD.
	 * @param note
	 */
	public void addNote(Note note) {
		this.addPublications(note);
	}

	/**
	 * Adiciona um conteudo 'a BD.
	 * @param content
	 */
	public void addContent(Content content) {
		this.addPublications(content);
	}

	/**
	 * Obtem um Set de comentarios de uma determianda publicaco por id
	 * de publicacao.
	 * @param id
	 * @return
	 */
	public Set<Comment> getPublicationCommentsByPublicationId(int id) {
		Publication pub = this.getPublicationById(id);
		Set<Comment> comments = pub.getCommentsSet();
		return comments;
	}

	/**
	 * Efectua um pedido de ligacao entre dois agentes.
	 * @param from
	 * @param to
	 */
	public void friendRequest(Individual from, Agent to) {
		if(!from.checkFriendLimit(this.getFriendLimit(), this.getAgentFriendNumber(from)) && !to.checkFriendLimit(this.getFriendLimit(), this.getAgentFriendNumber(to))){
			from.sendFriendRequest(to);
		}
	}

	/**
	 * Confirma um pedido de ligacao entre dois agentes do tipo Individual.
	 * @param from
	 * @param to
	 */
	public void confirmFriendRequest(Individual from, Individual to) {
		if(!from.checkFriendLimit(this.getFriendLimit(), this.getAgentFriendNumber(from)) && !to.checkFriendLimit(this.getFriendLimit(), this.getAgentFriendNumber(to))){
			to.acceptRequest(from);
		}
	}

	/**
	 * Recusa um pedido de ligacao entre dois agentes do tipo Individual.
	 * @param from
	 * @param to
	 */
	public void refuseFriendRequest(Individual from, Individual to) {
		to.refuseRequest(from);
	}

	/**
	 * Adiciona, se possivel, um voto positivo a uma publicacao
	 * 
	 * @param Agent voter - agente que vota na publicacao
	 * @param Publication pub - publicacao na qual se vai votar
	 */
	public void posVote(Agent voter, Publication pub) {
		voter.positiveVote(pub);
	}

	/**
	 * Adiciona, se possivel, um voto negativo a uma publicacao
	 * 
	 * @param Agent voter - agente que vota na publicacao
	 * @param Publication pub - publicacao na qual se vai votar
	 */
	public void negVote(Agent voter, Publication pub) {
		voter.negativeVote(pub);
	}

	/**
	 * Verifica se um agente Individual ja excedeu o limite de amigos
	 * 
	 * @param Individual agent - agente a verificar
	 * 
	 */
	public int getAgentFriendNumber(Agent agent) {
		int friends=0;

		for(Agent p : this.getAgentSet()){
			if (p.isMyFriend(agent))
				friends++;
		}

		return friends;
	}
	
	/**
	 * Lista todos os amigos de um dado agent
	 * 
	 * @param Individual agent - agente a verificar
	 * @return ArrayList<Agent> - Lista de Agents que sao amigo do agent
	 * 
	 */
	public ArrayList<Agent> getFriendsOf(Agent agent) {
		ArrayList<Agent> list = new ArrayList<Agent>();
		for(Agent p : this.getAgentSet()){
			if (p.isMyFriend(agent))
				list.add(p);
		}
		return list;
	}

}
